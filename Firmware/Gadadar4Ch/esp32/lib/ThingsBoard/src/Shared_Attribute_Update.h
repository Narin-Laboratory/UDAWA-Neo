#ifndef Shared_Attribute_Update_h
#define Shared_Attribute_Update_h

// Local includes.
#include "Shared_Attribute_Callback.h"
#include "IAPI_Implementation.h"


// Log messages.
#if !THINGSBOARD_ENABLE_DYNAMIC
char constexpr SHARED_ATTRIBUTE_UPDATE_SUBSCRIPTIONS[] = "shared attribute update";
#endif // !THINGSBOARD_ENABLE_DYNAMIC


/// @brief Handles the internal implementation of the ThingsBoard shared Attribute Update API.
/// See https://thingsboard.io/docs/reference/mqtt-api/#subscribe-to-attribute-updates-from-the-server for more information
/// @tparam Logger Implementation that should be used to print error messages generated by internal processes and additional debugging messages if THINGSBOARD_ENABLE_DEBUG is set, default = DefaultLogger
#if THINGSBOARD_ENABLE_DYNAMIC
template <typename Logger = DefaultLogger>
#else
/// @tparam MaxSubscriptions Maximum amount of simultaneous shared attribute update subscriptions.
/// Once the maximum amount has been reached it is not possible to increase the size, this is done because it allows to allcoate the memory on the stack instead of the heap, default = DEFAULT_SUBSCRIPTION_AMOUNT (1)
/// @tparam MaxAttributes Maximum amount of attributes that will ever be subscribed with one @ref Shared_Attribute_Callback, allows to use an array on the stack in the background, default = DEFAULT_ATTRIBUTES_AMOUNT (1)
template<size_t MaxSubscriptions = DEFAULT_SUBSCRIPTION_AMOUNT, size_t MaxAttributes = DEFAULT_ATTRIBUTES_AMOUNT, typename Logger = DefaultLogger>
#endif // THINGSBOARD_ENABLE_DYNAMIC
class Shared_Attribute_Update : public IAPI_Implementation {
#if THINGSBOARD_ENABLE_DYNAMIC
    using Callback_Value = Shared_Attribute_Callback;
    using Callback_Container = Container<Callback_Value>;
#else
    using Callback_Value = Shared_Attribute_Callback<MaxAttributes>;
    using Callback_Container = Container<Callback_Value, MaxSubscriptions>;
#endif // THINGSBOARD_ENABLE_DYNAMIC

  public:
    /// @brief Constructor
    Shared_Attribute_Update() = default;

    ~Shared_Attribute_Update() override = default;

    /// @brief Subscribes shared attribute callbacks, that will be called if an update for the containing shared attributes is received
    /// @note Can be called even if we are currently not connected to the cloud,
    /// this is the case because the only interaction that requires an active connection is the subscription of the topic that we receive the response on
    /// and that subscription is also done automatically by the library once the device has established a connection to the cloud.
    /// Therefore this method can simply be called once at startup before a connection has been established
    /// and will then automatically handle the subscription of the topic once the connection has been established.
    /// See https://thingsboard.io/docs/reference/mqtt-api/#subscribe-to-attribute-updates-from-the-server for more information
    /// @tparam InputIterator Class that allows for forward incrementable access to data
    /// of the given data container, allows for using / passing either std::vector or std::array.
    /// See https://en.cppreference.com/w/cpp/iterator/input_iterator for more information on the requirements of the iterator
    /// @param first Iterator pointing to the first element in the data container
    /// @param last Iterator pointing to the end of the data container (last element + 1)
    /// @return Whether subscribing the given callbacks was successful or not
    template<typename InputIterator>
    bool Shared_Attributes_Subscribe(InputIterator const & first, InputIterator const & last) {
#if !THINGSBOARD_ENABLE_DYNAMIC
        auto const size = Helper::distance(first, last);
        if (m_shared_attribute_update_callbacks.size() + size > m_shared_attribute_update_callbacks.capacity()) {
            Logger::printfln(MAX_SUBSCRIPTIONS_EXCEEDED, SHARED_ATTRIBUTE_UPDATE_SUBSCRIPTIONS, MAX_SUBSCRIPTIONS_TEMPLATE_NAME);
            return false;
        }
#endif // !THINGSBOARD_ENABLE_DYNAMIC
        (void)m_subscribe_topic_callback.Call_Callback(ATTRIBUTE_TOPIC);
        // Push back complete vector into our local m_shared_attribute_update_callbacks vector.
        m_shared_attribute_update_callbacks.insert(m_shared_attribute_update_callbacks.end(), first, last);
        return true;
    }

    /// @brief Subscribes a shared attribute callback, that will be called if an update for the containing shared attributes is received
    /// @note Can be called even if we are currently not connected to the cloud,
    /// this is the case because the only interaction that requires an active connection is the subscription of the topic that we receive the response on
    /// and that subscription is also done automatically by the library once the device has established a connection to the cloud.
    /// Therefore this method can simply be called once at startup before a connection has been established
    /// and will then automatically handle the subscription of the topic once the connection has been established.
    /// See https://thingsboard.io/docs/reference/mqtt-api/#subscribe-to-attribute-updates-from-the-server for more information
    /// @param callback Callback method that will be called
    /// @return Whether subscribing the given callback was successful or not
    bool Shared_Attributes_Subscribe(Callback_Value const & callback) {
#if !THINGSBOARD_ENABLE_DYNAMIC
        if (m_shared_attribute_update_callbacks.size() + 1U > m_shared_attribute_update_callbacks.capacity()) {
            Logger::printfln(MAX_SUBSCRIPTIONS_EXCEEDED, SHARED_ATTRIBUTE_UPDATE_SUBSCRIPTIONS, MAX_SUBSCRIPTIONS_TEMPLATE_NAME);
            return false;
        }
#endif // !THINGSBOARD_ENABLE_DYNAMIC
        (void)m_subscribe_topic_callback.Call_Callback(ATTRIBUTE_TOPIC);
        m_shared_attribute_update_callbacks.push_back(callback);
        return true;
    }

    /// @brief Unsubcribes all shared attribute callbacks.
    /// See https://thingsboard.io/docs/reference/mqtt-api/#subscribe-to-attribute-updates-from-the-server for more information
    /// @return Whether unsubscribing all the previously subscribed callbacks
    /// and from the attribute topic, was successful or not
    bool Shared_Attributes_Unsubscribe() {
        m_shared_attribute_update_callbacks.clear();
        return m_unsubscribe_topic_callback.Call_Callback(ATTRIBUTE_TOPIC);
    }

    API_Process_Type Get_Process_Type() const override {
        return API_Process_Type::JSON;
    }

    void Process_Response(char const * topic, uint8_t * payload, uint32_t length) override {
        // Nothing to do
    }

    void Process_Json_Response(char const * topic, JsonDocument const & data) override {
        JsonObjectConst object = data.template as<JsonObjectConst>();
        if (object.containsKey(SHARED_RESPONSE_KEY)) {
            object = object[SHARED_RESPONSE_KEY];
        }

#if THINGSBOARD_ENABLE_STL
#if THINGSBOARD_ENABLE_CXX20
        auto filtered_shared_attribute_update_callbacks = m_shared_attribute_update_callbacks | std::views::filter([&object](Callback_Value const & shared_attribute) {
#else
        Callback_Container filtered_shared_attribute_update_callbacks = {};
        std::copy_if(m_shared_attribute_update_callbacks.begin(), m_shared_attribute_update_callbacks.end(), std::back_inserter(filtered_shared_attribute_update_callbacks), [&object](Callback_Value const & shared_attribute) {
#endif // THINGSBOARD_ENABLE_CXX20
            return (shared_attribute.Get_Attributes().empty() || std::find_if(shared_attribute.Get_Attributes().begin(), shared_attribute.Get_Attributes().end(), [&object](const char * att) {
                return object.containsKey(att);
            }) != shared_attribute.Get_Attributes().end());
        });

        for (auto const & shared_attribute : filtered_shared_attribute_update_callbacks) {
#else
        for (auto const & shared_attribute : m_shared_attribute_update_callbacks) {
            if (shared_attribute.Get_Attributes().empty()) {
                // No specifc keys were subscribed so we call the callback anyway, assumed to be subscribed to every shared attribute update
                shared_attribute.Call_Callback(object);
                continue;
            }

            char const * requested_att = nullptr;

            for (auto const & att : shared_attribute.Get_Attributes()) {
                if (Helper::String_IsNull_Or_Empty(att)) {
                    continue;
                }
                // Check if the shared attribute update contains any of our subscribed keys and break early if they do,
                // because we want to receive every update that chagned atleast one of our subscribed keys
                if (object.containsKey(att)) {
                    requested_att = att;
                    break;
                }
            }

            // Check if the shared attribute update contained any of our subscribed keys.
            // Do not inform the callback if it did not
            if (requested_att == nullptr) {
                continue;
            }
#endif // THINGSBOARD_ENABLE_STL
            shared_attribute.Call_Callback(object);
        }
    }

    bool Is_Response_Topic_Matching(char const * topic) const override {
        return strncmp(ATTRIBUTE_TOPIC, topic, strlen(ATTRIBUTE_TOPIC) + 1) == 0;
    }

    bool Unsubscribe() override {
        return Shared_Attributes_Unsubscribe();
    }

    bool Resubscribe_Permanent_Subscriptions() override {
        if (!m_shared_attribute_update_callbacks.empty() && !m_subscribe_topic_callback.Call_Callback(ATTRIBUTE_TOPIC)) {
            Logger::printfln(SUBSCRIBE_TOPIC_FAILED, ATTRIBUTE_TOPIC);
            return false;
        }
        return true;
    }

#if !THINGSBOARD_USE_ESP_TIMER
    void loop() override {
        // Nothing to do
    }
#endif // !THINGSBOARD_USE_ESP_TIMER

    void Initialize() override {
        // Nothing to do
    }

    void Set_Client_Callbacks(Callback<void, IAPI_Implementation &>::function subscribe_api_callback, Callback<bool, char const * const, JsonDocument const &>::function send_json_callback, Callback<bool, char const * const, char const * const>::function send_json_string_callback, Callback<bool, char const * const>::function subscribe_topic_callback, Callback<bool, char const * const>::function unsubscribe_topic_callback, Callback<uint16_t>::function get_receive_size_callback, Callback<uint16_t>::function get_send_size_callback, Callback<bool, uint16_t, uint16_t>::function set_buffer_size_callback, Callback<size_t *>::function get_request_id_callback) override {
        m_subscribe_topic_callback.Set_Callback(subscribe_topic_callback);
        m_unsubscribe_topic_callback.Set_Callback(unsubscribe_topic_callback);
    }

  private:
    Callback<bool, char const * const>                                       m_subscribe_topic_callback = {};          // Subscribe mqtt topic client callback
    Callback<bool, char const * const>                                       m_unsubscribe_topic_callback = {};        // Unubscribe mqtt topic client callback
    Callback_Container                                                       m_shared_attribute_update_callbacks = {}; // Shared attribute update callbacks array
};

#endif // Shared_Attribute_Update_h
